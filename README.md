# Undersorcery
![Undersorcery logo](art/logo.png)

[![Build Status](https://travis-ci.org/zoltan-mihalyi/undersorcery.svg?branch=master)](https://travis-ci.org/zoltan-mihalyi/undersorcery) [![codecov](https://codecov.io/gh/zoltan-mihalyi/undersorcery/branch/master/graph/badge.svg)](https://codecov.io/gh/zoltan-mihalyi/undersorcery)

Undersorcery is a functional helper library for node.js.

Unlike underscore or lodash, its methods does not process data, rather **generating efficient functions**, which can be used later to process data very fast.

For example:
```javascript
var u = require('undersorcery');
var findZoliScores = u()
    .where({name: 'Zoli'})
    .pluck('score')
    .fn();

findZoliScores([{name: 'Orsi', score: 5}, {name: 'Zoli', score: 3}]); //[3]
```

The generated function is something like this:
```javascript
function findZoliScores(array) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        var x = array[i];
        if (x.name === 'Zoli') {
            return x.id;
        }
    }
}
```

In general, processing data with the functions generated by undersorcery are much faster than using other functional helpers, when:
- You know the parameters of the functions before processing data, e.g. the where filter or the property name.
- Or you use chaining (underscore won't create arrays for intermediate steps)

However, function generation takes some time, so consider using it only when the function is used a lot afterwards.

## Installing
`npm install undersorcery`

## Basic usage

Start the chain with `u()` and don't forget the `.fn()` at the end!
The complete list of methods is the same as in underscore collection, array and object methods: http://underscorejs.org/

```javascript
var u = require('undersorcery');

var transformation = u()
    .map(function(x) {
        return x + 1;
    })
    .filter(function() {
        return x < 5
    })
    .first(2)
    .fn();

//transformation phase:
var result = transformation([1, 2, 3, 4, 5]); //[2, 3]
```

## Type hints

It is possible to define the type of the transformation's parameter, in order to avoid type checks. Possible types are 'array' or 'map'.

```javascript
u('array')
    .pluck('score')
    .fn(); //no isArray check in the function, just a simple for loop.
```

## Optimizations

- When two or more transformations are chained, undersorcery does not create intermediate arrays, and uses loop fusion.
- When only a range of the computed elements is needed (range, take...), the elements outside the range are not computed.
- Range transformations are merged to create a more efficient transformation.
- When the iteratee function passed to methods like map, filter, etc. does not use the index or the value parameters, they aren't computed at all!
- Hints are used to eliminate type checks at runtime.
- Some methods do less work if only the length of the result matters at the end.
- Loops in isEqual, where, and similar matchers are unrolled.
- Faster, fixed size arrays are used, when length is known.

## Benchmarks

In progress.

## Limitations

- Compared to underscore, the reference to the complete list is not passed to iteratee functions.
- Right now you have to have all of the parameters when generating the function, there is no way to define it as runtime parameter.
However it is a planned feature in the next release:

```javascript
var pluck = u()
    .map(u.param('mapper'))
    .pluck(u.param('property')) //not implemented yet!
    .fn();

pluck([{a: 1}, {a: 2}], {mapper: function(){}, property: 'a'});
```
